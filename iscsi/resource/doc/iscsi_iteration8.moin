# = iSCSI优化迭代过程8 =
<<TableOfContents>>

	* 时间 20100628 - 20100630
	* SVN库版本号：449
----
== 解决Windows顺序写提交的请求非顺序问题 ==

Windows下使用iometer测试顺序写性能时，提交的scsi写请求并非按顺序，从而产生大量普通方式的RAID写操作，导致性能变慢。<<BR>>
* 注：iometer 的# outstanding 为1时没有此现象，# outstanding越大，该现象就越突出。

解决方法：
	* 原来只有一个 bio_pending，现改为有多个 bio_pending 存放在 bio_pending_list 列表中
	* 每一个 bio_pending 对应一个整条带
	* 当填充满一个整条带或超时才提交一个 bio_pending

struct bio_info 中增加定义：
{{{#!cplusplus
///bio_info 开始使用时的时间
unsigned long pending_jiffies;
///pending状态时为整条带的起始位置， 提交时为bi_sector对应的位置
loff_t loff_start;
}}}

struct scst_vdisk_dev 中增加定义:
{{{#!cplusplus
struct list_head bio_pending_list;

///pending超时的jiffies数，取 2 秒 = 200 jiffies
unsigned long pending_timeout_jiffies;
}}}

blockio_exec_write()函数的处理:

{{{#!cplusplus
/*		
	* 由lba_start从bio_pending_list搜索所属的bio_info
	* 如果搜到:
		* need_new_bio = 0
		* 把 sgv 加入 bio_info->sgv_ptr_list
	* 否则:
		* need_new_bio = 1
		* 计算 loff_start
		
	* 计算页索引 idx
	* search_pending_bio = 0;
*/

	bytes = 0;
	length = scst_get_buf_first(cmd, &address);
	while (length > 0) {
		int off;
		struct page *page = virt_to_page(addr);
		
		off = offset_in_page(addr);

		//此处必须有bytes == PAGE_SIZE，off == 0
		if (length != PAGE_SIZE || off != 0) {
			PRINT_ERROR("AAAAAAAAAAAAA %s", "blockio_exec_write length != PAGE_SIZE  || off != 0");
		}

/*
		* 如果 search_pending_bio:
			* search_pending_bio = 0;
			* 由lba_start从bio_pending_list搜索所属的bio_info
			* 如果搜到:
				* need_new_bio = 0;
				* 把 sgv 加入 bio_info->sgv_ptr_list
			* 否则:
				* need_new_bio = 1;
				* loff_start = (loff_t)(lba_start << virt_dev->block_shift);
			* idx = 0; //此时lba_start一定是对齐到整条带边界
*/

		if (need_new_bio) {
			bio_info = get_idle_bio_info(virt_dev);
			if (!bio_info) {
				goto out_no_bio;
			}
			need_new_bio = 0;

			bio_info->pending_jiffies = jiffies;
			
			// * 把 sgv 加入 bio_info->sgv_ptr_list
			
			//设置bio
			bio_info->bio->bi_end_io = blockio_endio_write;
			//在提交bio_info时再设置 bio_info->bio->bi_sector
//			bio_info->bio->bi_sector = lba_start <<
//					(virt_dev->block_shift - 9);
			bio_info->bio->bi_bdev = bdev;
			bio_info->loff_start = loff_start;
			bio_info->write = 1;
		} //if (need_new_bio)

		//该函数内部根据 bio_info->pages[idx] == NULL时 累加 bio_info->length
		bio_info_add_page(bio_info, page, idx);
		
		idx++;
		
		if(idx == virt_dev->full_stripe_pages) {
			//下一页数据位置已经超出当前 bio_info 的 stripe
			//此时下一页位置对齐到 full_stripe_size
			search_pending_bio = 1;
/*
			* 如果bio_info->length == full_stripe_size:
				* 此时已得到一个整条带数据，按FSW方式提交bio_info
*/
		}
		
		lba_start += length >> virt_dev->block_shift;
		
		scst_put_buf(cmd, address);
		length = scst_get_buf_next(cmd, &address);
	} //while (length > 0) {
	
/*
	* 如果 !search_pending_bio && bio_info->length == full_stripe_size:
		* 此时已得到一个整条带数据，按FSW方式提交bio_info
	
	* 如果 bio_info 是新的且未提交就按写入位置顺序加入 bio_pending_list 中
*/

}}}

bio_search_overlap() 函数的修改：
{{{#!cplusplus
static inline bool bio_search_overlap(bio_info_t* bio_info)
{
	//搜索bio与bio_normal_list, bio_fsw_list bio链表中的bio是否有写入位置重叠
	bool overlap = false;

// 	//如果是读, 需要判断是否和bio_pending重叠
// 	PRINT_ERROR("AAAAAAAAAAAA bio_info: %p, bio_pending: %p, write: %d bio_pending->loff_start: %lld, bio_pending->length: %d", 
// 				bio_info, bio_info->virt_dev->bio_pending, bio_info->write, bio_info->virt_dev->bio_pending->loff_start, bio_info->virt_dev->bio_pending->length);
	if (bio_info->write == 0 ) {
/*
		* 从前向后循环 bio_pend_list 中的每一个元素 bio_pending:
			* 如果 bio_info->loff_start < bio_pending->loff_start
				* 如果 bio_info->loff_start + bio_info->length <= bio_pending->loff_start:
					* 此时不与条带重叠，不用再搜索
					* break;
			* 否则:
				* 如果 bio_info->loff_start >= bio_pending->loff_start + full_stripe_size:
					* 此时不与条带重叠，需要继续搜索
					* continue;
			
			* 此时一定与条带重叠
			
 			* 把 bio_pending 从链表中删除
 			
			dispatch_bio(bio_pending, ACT_SUBMIT_PENDING_TO_NORMAL, NULL);

*/
	}

	overlap |= bio_search_overlap_by_list(bio_info, &bio_info->virt_dev->bio_fsw_list);
	overlap |= bio_search_overlap_by_list(bio_info, &bio_info->virt_dev->bio_normal_list);
	
	return overlap;
}
}}}

dispatch_bio()函数 case ACT_SUBMIT_PENDING_TO_NORMAL的修改:
{{{#!cplusplus
bio_info_t *bio_normal;
sgv_info_t *sgv_info1;
ptr_entry_t *ptr_entry1;
int rc, i;
loff_t loff_start = bio_info->loff_start;

// 			printk("AAAAAAAA dispatch_bio, ACT_SUBMIT_PENDING_TO_NORMAL, bio_info->length: %d", bio_info->length);

bio_normal = bio_info;
bio_normal->length = 0;

for (i=0; i<virt_dev->full_stripe_pages; ++i) {
	if(bio_info->pages[i] == NULL) {
		if(bio_normal->length > 0) {
			rc = 0;
		} else {
			continue;
		}
	} else {
ADD_PAGE:
		if(bio_normal->length == 0){
			bio_normal->loff_start = loff_start + i*PAGE_SIZE;
			bio_normal->bio->bi_sector = bio_normal->loff_start >> 9;
		}
		
		rc = bio_add_page(bio_normal->bio, bio_info->pages[i], PAGE_SIZE, 0);
	}
		
	if (rc < PAGE_SIZE) {
		//normal方式提交bio
		dispatch_bio(bio_normal, ACT_SUBMIT_NORMAL, NULL);
		
		//new bio
		bio_normal = get_idle_bio_info(virt_dev);
		
		//bio相关的设置
		bio_normal->bio->bi_end_io = blockio_endio_write;
		bio_normal->bio->bi_bdev = bio_info->bio->bi_bdev;					
		bio_normal->write = bio_info->write;

		//bio_info中的所有sgv链入bio_normal
		list_for_each_entry(ptr_entry, &bio_info->sgv_ptr_list, ptr_list_entry) {
			ptr_entry1 = get_idle_ptr_entry(&bio_info->virt_dev->ptr_idle_list);
			ptr_entry1->ptr = ptr_entry->ptr;
			list_add_tail(&ptr_entry1->ptr_list_entry, &bio_normal->sgv_ptr_list);
			sgv_info1 = (sgv_info_t *)ptr_entry1->ptr;
			++sgv_info1->ref_count;
		}
		
		if(bio_info->pages[i] != NULL)
			goto ADD_PAGE;
		else
			continue;
	}//if (rc < PAGE_SIZE) {
	bio_normal->length += PAGE_SIZE;
}//for (i=0; i<cnt_page_total; ++i)

//提交剩余的bio
if(bio_normal->length > 0){
	dispatch_bio(bio_normal, ACT_SUBMIT_NORMAL, NULL);
}else{
	add_idle_bio(bio_normal);
}

break;
}}}

do_job_vdisk()超时处理函数的修改：
	* unsigned long jiffies_now = jiffies;
	* 如果 jiffies_now - virt_dev->check_pending_jiffies > virt_dev->check_pending_timeout_jiffies:
		* 每隔 0.5 秒检查一次 bio_pending_list 中的 bio_info 是否已超时
		* virt_dev->check_pending_timeout_jiffies 取 0.5 sec = 50 jiffies
		* 从前向后循环 bio_pending_list 中的每一个元素 bio_pending:
			* 如果 jiffies_now - bio_pending->pending_jiffies > virt_dev->pending_timeout_jiffies:
				* 把 bio_pending 从链表中删除
				* dispatch_bio(bio_pending, ACT_SUBMIT_PENDING_TO_NORMAL, NULL);

vdisk_do_job()函数的修改：
{{{#!cplusplus

if(virt_dev->fsw_status == FSW_ENABLE) {
	blockio_exec_write(cmd, thr, lba_start);
} else {
	if(unlikely(!list_empty(&virt_dev->bio_pending_list))) {
		// * 按 ACT_SUBMIT_PENDING_TO_NORMAL 提交所有pending
	}
	
	// blockio_exec_write_normal() 函数使用 dispatch_bio(ACT_SUBMIT_NORMAL) 方式提交 bio
	blockio_exec_write_normal(cmd, thr, lba_start);
}

}}}
----
[[Category-WisESP]]
